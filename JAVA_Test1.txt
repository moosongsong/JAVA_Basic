1. 캡슐화에 대해 기술하세요.
객체지향프로그래밍의 특징은 캡슐화, 상속, 다형성 이렇게 세가지이다.
캡슐화란 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 의미한다.
외부객체는 객체의 내부 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
필드와 메소드를 캡슐화 하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다. 
자바 언어는 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자를 사용한다. 
접근제한자는 객체의 필드와 메소드의 사용 범위를 제한함으로써 외부로부터 보호한다.
특히 캡슐화는 속성/행위들을 내부로 넣고 인터페이스를 통해서 외부와 소통하는데 이는 내부를 숨김으로써, 모듈의 독립성을 높여주는데 효율적이다.
또한 추상화의 단위가 된다.


2. 정보은닉에 대해 기술하세요.
캡슐화의 핵심으로, 캡슐화 되어있는 데이터와 함수들에 대해서 외부에서 해당 함수가 어떻게 구현되어있는지에 대한 세부사항을 숨기는 것이다. 
그렇다고 해서 캡슐화를 하였다고 반드시 정보은닉이 되는 것은 아니기에 개발자의 센스가 필요하다.


3. 추상화에 대해 기술하세요.
추상화란 복잡한 문제를 다루기 위해서 불필요한 부분들을 숨기고 중요한 부분만을 표현하는 것을 의미한다. 
따라서 캡슐화를 하면 추상화가 된다고 볼 수 있다. 캡슐단위의 의미있는 단위로만 보여주기에 추상화의 단위가 될 수 있다.
기본적으로 추상클래스는 상속을 통해 기능을 확장하려는 목적을 가지고 있다. 
이에 반해 인터페이스는 인터페이스를 구현한 객체들에 대해 동일한 동작을 약속하는 것이다. 


4. 다형성에 대해 기술하세요.
다형성은 같은 타입이지만 실행결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 
코드측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.
자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다.
부모 타입에는 모든 자식객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현객체가 대입될 수 있다.
다형성의 효과로 객체는 부품화가 가능하다. 즉 객체지향의 궁극적인 의의를 지닌 단어라고 볼 수 있다.


5. 다음 코드에 대한 설명을 기술하세요.

	interface Runnable {
		void run();
	}

	class Hors implements Runnable {

	}
해당 코드는 Runnable 인터페이스를 Horse 클래스가 구현을 하고자 하는 코드이다.
즉 말 클래스는 달릴 수 있음을 표하고자 하며, 여기서 중요한 점은 Horse 인터페이스를 받은 다른 객체들과
같이 그룹화되는 것에 더해, run이라는 메소드를 인터페이스 자료형으로 호출이 가능하다는 것이다.
하지만, 해당 run();메소드를 반드시 구현해야하며, 구현하기 싫을 경우 자신도 추상형이 되면 된다.


6. 추상형(추상클래스 또는 인터페이스)에 맞추어 설계를 해야 하는 이유를 기술하세요.
그룹화 즉 다형성을 이루기 위해서, 또한 상속을 통해 기능을 확장하려는 목적을 가지고 있다. 
또는 인터페이스를 구현한 객체들에 대해 동일한 동작을 약속하는 것이다. 
중복된 코드의 해결,상속을 통한 기능 확장, cost감소, 다형성 목적



7. 다음 코드에 대한 설명을 기술하세요.

	interface Runnable {
	}

	class Horse implements Runnable
	
위의 코드는 Runnable 이라는 인터페이스를 Horse class에서 구현을 시도하고 있는 코드이다.
이 구현은 Horse 클래스가 Runnble 즉 달릴수 있는 객체임을 표시하는 정도의 구현이며, 
이는 타 객체중 Runnable을 구현한 객체들과, Runnable 에 의한 구룹화를 목적으로 둔 코드라고 볼수있다.


8. 다음 코드가 실행이 불가능한 이유를 설명하고 실행 가능하도록 수정하세요.

	class Person {

	}

	class Student extends Person {
		public void study() {
			System.out.println("공부합니다.");
		}
	}

	Person p = new Student();
	p.study();

 우선 이 코드는 student 클래스가 person 클래스를 상속받도록 하여, Person 타입으로 다루기위한 시도이다.
 다형성을 이용하고자 해당 클래스를 상속받았다고 볼 수 있다.
 따라서 필드멤버 p의 자료형은 Person 임에도 불구하고, Student 인스턴스를 생성할 수 있게 된것이다.
 하지만 여기서 간과한 점은 인스턴스 메소드 실행시, 해당 메소드가 호출이 가능한지 레퍼런스의 자료형으로 승인이되고, 
 승인 이후, 인스턴스의 메소드가 실행되는 것이다.
 결국 위의 코드는 Person타입으로 study();메소드를 승인받으려고 했으나, Person 클래스에는 해당 메소드가 존재하지 않으므로
 승인이 되지 않고, 메소드를 호출할 수 없게되어 에러가 발생한다.
