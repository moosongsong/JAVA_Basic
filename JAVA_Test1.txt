1. 캡슐화에 대해 기술하세요.(정의, 무엇을, 왜, 어떻게)
서로관련있는 메소드와 필드를 묶어 class의 형태로 만듦으로써 내부와 외부를 구분짓는게 캡슐화이다.
외부객체는 객체의 내부 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
특히 캡슐화는 속성/행위들을 내부로 넣고 인터페이스를 통해서 외부와 소통하는데 이는 모듈의 독립성을 높여주는데 효율적이다.

서로 관련성있는거 묶어주는거
관련성이 있다는 건 하나의 객체가 존재하고 속성과 행위를 묶어주는거(연관있는거)
클래스에 의해 구현된다. 생성되는 객체는 내부와 외부로 구분된다.
왜 캡슐의 내외부 구분짓기 위함.


2. 정보은닉에 대해 기술하세요.
캡슐화 되어있는 데이터와 함수들에 대해서 외부에서 해당 함수가 어떻게 구현되어있는지에 대한 세부사항을 숨기는 것이다. 
접근 제한자를 사용함으로써 객체의 필드와 메소드의 사용 범위를 제한하여 외부로부터 보호한다.

정보를 숨기는 것 임포메이션 하이딩
캡슐 내부에 있는 것을 외부에서 보이지 않게끔
보호를 하겠다.
보호를 한다는 의미는 직접접근을 허용 노노
잘못된 값이 멤버로 들어갈 수 있기에 숨기는 것
외부에서 참조할 경우 겟셋 제공
적어도 들어갈때의 타당성 검사할 수 있는 기회 한번이상 가능
캡슐화 선행되어야 한다. 접근제한자에 의해 실현된다.


3. 추상화에 대해 기술하세요.
추상화란 복잡한 문제를 다루기 위해서 불필요한 부분들을 숨기고 중요한 부분만을 표현하는 것을 의미한다. 
따라서 캡슐화를 하면 추상화가 된다고 볼 수 있다. 캡슐단위의 의미있는 단위로만 보여주기에 추상화의 단위가 될 수 있다.
기본적으로 추상클래스는 상속을 통해 기능을 확장하려는 목적을 가지고 있다. 의존도가 낮아진다 모듈의 독립성이 높아진다.

숨기는 것이 많으면 많을 수록 외부에서는 적게보인다. 내부에 아무리 많아도 일부만 보인다 간략화 되어 보인다.
어렵고 복잡한 것을 간략화, 추상화 정도 높다 숨기는 것 많을 수록 추상화 정도가 높다
인터페이스 제공해야함. 인터페이스 제공=명세를 제공=추상메소드 제공
추상 클래스가 가지고 있는 것은 자식 클래스가 가지고 있는 거 잘 쓸 수 있음.
추상화가 되어있는 객체에 대한 명세 제공=인터페이스
보여짐이 줄수록 외부에서의 참조점이 줄어든다.
참조 높 의존도 높 모듈화 낮
모듈=함수, 클래스, .o .class 애가 모듈
제공시 모듈로 준다(컴파일된 파일을 준다.)
모듈=재사용 단위, 다른데에 가져다 쓸 수 있어야.
연결점이 많으면 사용하기 어려워진다. 모듈이 독립성 낮다.
많이 숨길 수록 의존도가 낮아진다 모듈의 독립성이 높아진다. 재사용성 높



4. 다형성에 대해 기술하세요.
다형성은 같은 타입이지만 실행결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 
코드측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.
자바는 다형성을 위해 클래스, 인터페이스 간 타입 변환을 허용한다.
다형성의 효과로 객체는 부품화가 가능하다. 즉 객체지향의 궁극적인 의의를 지닌 단어라고 볼 수 있다.

주어진 조건에 따라 다양한 연산결과
메서드를 연산이라고 한다.
오버로딩과 오버라이딩에 의해 다형성이 실행된다.
오버로딩은 동일한 클래스 동일한 이름의 메소드
시그니처에 의해서 메소드 결정, 인수의 파라미터 명은 제외된다.
식별자가 같지만 주어지는 인수에 따라서 실행되는 메소드 달라짐
오버라이딩 상위 클래스에서 선언 정의 한거
재정의 구현 하위에서 하는 거
오버라이딩의 조건 상위 클래서에서 선언한 시그니처를 그대로 사용
접근제한자는 상위 클래스 이상으로 사용해야함.
인스턴스 함수를 참조할때 객체를 통해 참조.
시그니처가 동일하다 하더라도, 어떤 객체를 대상으로 실행이 되느냐가 달라진다.
오버라이딩은 호출주체가 조건이된다.


5. 다음 코드에 대한 설명을 기술하세요.

	interface Runnable {
		void run();
	}

	class Hors implements Runnable {

	}
해당 코드는 Runnable 인터페이스를 Horse 클래스가 구현을 하고자 하는 코드이다.
즉 말 클래스는 달릴 수 있음을 표하고자 하며, 여기서 중요한 점은 Horse 인터페이스를 받은 다른 객체들과
같이 그룹화되는 것에 더해, run이라는 메소드를 인터페이스 자료형으로 호출이 가능하다는 것이다.
하지만, 해당 run();메소드를 반드시 구현해야하며, 구현하기 싫을 경우 자신도 추상형이 되면 된다.

말만 달릴 수 있는게 아니다. 다양한 객체들이 달릴 수 있다.
그런데 다 일반화 할순 없다. 달리는 방식들이 각자 다르다.
일반화 하려면 오브젝트로 해야하는데 오브젝트는 run 없자나

모든 객체가 상속을 통해서 구룹화를 할 수 있지만, 모든 객체들이 일반화 될 수 있는 건 아니다.
속성이 달라. 인터페이스에는 멤버 필드가 그래서 없다.
행동 만큼은 일반화 할 수 있다. 인터페이스로
구현한 애들은 run이 다 구현되어 있을 것이고, runnable로 구룹화 할 수 있다.


6. 추상형(추상클래스 또는 인터페이스)에 맞추어 설계를 해야 하는 이유를 기술하세요.
그룹화 즉 다형성을 이루기 위해서, 또한 상속을 통해 기능을 확장하려는 목적을 가지고 있다. 
중복된 코드의 해결,상속을 통한 기능 확장, cost감소, 다형성 목적

대표타입에 맞추어 설계하라.
구현클래스에 맞춰서 설계를 하면 일대 다의 관계가 형성된다.
대리점 벤츠 BMW
대리점 자동차 -> 이렇게 의존도를 낮출 수 있음.

7. 다음 코드에 대한 설명을 기술하세요.

	interface Runnable {
	}

	class Horse implements Runnable
	
위의 코드는 Runnable 이라는 인터페이스를 Horse class에서 구현을 시도하고 있는 코드이다.
이 구현은 Horse 클래스가 Runnble 즉 달릴수 있는 객체임을 표시하는 정도의 구현이며, 
이는 타 객체중 Runnable을 구현한 객체들과, Runnable 에 의한 구룹화를 목적으로 둔 코드라고 볼수있다.

멤버 메소드가 없는 인터페이스는 구현해야할 기능이 없다.
대표타입이 될 수 있다.
clonable은 인터페이스인데 메소드가 없다.
오브젝트로 부터 상속받은 것을 오버라이딩.
이 인터페이스가 없으면 복제 불가하자나
복제하는 코드는 JVM에 있어
오브젝트까지 올라오는데, 
의뢰하기전 복제가능 여부를 판단한다.
타입을 판단함으로써.
JVM에게 알려주기위한 용도.JVM은 인스턴스가 생성된 시점의 메모리를 관리한다.


8. 다음 코드가 실행이 불가능한 이유를 설명하고 실행 가능하도록 수정하세요.

	class Person {

	}

	class Student extends Person {
		public void study() {
			System.out.println("공부합니다.");
		}
	}

	Person p = new Student();
	p.study();

 우선 이 코드는 student 클래스가 person 클래스를 상속받도록 하여, Person 타입으로 다루기위한 시도이다.
 다형성을 이용하고자 해당 클래스를 상속받았다고 볼 수 있다.
 따라서 필드멤버 p의 자료형은 Person 임에도 불구하고, Student 인스턴스를 생성할 수 있게 된것이다.
 하지만 여기서 간과한 점은 인스턴스 메소드 실행시, 해당 메소드가 호출이 가능한지 레퍼런스의 자료형으로 승인이되고, 
 승인 이후, 인스턴스의 메소드가 실행되는 것이다.
 결국 위의 코드는 Person타입으로 study();메소드를 승인받으려고 했으나, Person 클래스에는 해당 메소드가 존재하지 않으므로
 승인이 되지 않고, 메소드를 호출할 수 없게되어 에러가 발생한다.
 
 두가지의 절차
 승인, compile타임에 승인, 실행은 runtime
 인스턴스는 실행타임에 인스턴스가 생성된다.
 만들어지는 인스턴스는 몰라.
 그래서 컴파일 타임에 승인을 받는거야
 p 가 student 이면돼
 아니면 다운캐스팅
 보장하기 위해 intanceof를 사용하고 
 인터페이스를 만들건 study라는 추상형 클래스를 만들어 사용해도 된다.동적 바인딩.... 
 "동적바인딩!!!!"
